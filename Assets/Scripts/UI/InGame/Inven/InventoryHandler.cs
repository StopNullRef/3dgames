using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class InventoryHandler : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    /// <summary>
    /// 처음 드래그 될때 마우스위치에 넣어줄 이미지
    /// </summary>
    public Image tempSlotImage;

    /// <summary>
    /// 처음 tempslot 위치
    /// </summary>
    private Vector3 originTempSlotPos;

    /// <summary>
    /// tempslot 의 itemslot 컴포넌트
    /// </summary>
    public ItemSlot tempItemSlot;

    /// <summary>
    /// 인벤토리 하위에 아이템 슬롯 리스트
    /// </summary>
    public List<ItemSlot> itemSlots;

    /// <summary>
    /// BeginDrag 때 마우스위치에있는 슬롯의  itemSlot
    /// </summary>
    public ItemSlot beginDragItemSlot;

    /// <summary>
    /// endDrag 때 마우스위치에있는 슬롯의  itemSlot
    /// </summary>
    public ItemSlot endDragItemSlot;

    /// <summary>
    /// 인벤토리 RectTransform
    /// </summary>
    RectTransform invenRect;

    public void Awake()
    {
        SlotInitialize();
    }

    public void Start()
    {
        originTempSlotPos = tempSlotImage.transform.localPosition;
        tempItemSlot = tempSlotImage.GetComponent<ItemSlot>();
        invenRect = transform.GetComponent<RectTransform>();
    }

    /// <summary>
    /// 처음 슬롯 생성시켜주고 
    /// 리스트에 add해주는 함수
    /// </summary>
    public void SlotInitialize()
    {
        itemSlots.Clear();
        for (int i = 1; i < 26; i++)
        {
            //Instantiate(tempSlotImage, gameObject.transform).name = "Slot" + i;
            itemSlots.Add(gameObject.transform.GetChild(i - 1).GetComponent<ItemSlot>());
            itemSlots[i - 1].SlotInitialize();
        }

    }

    public void OnBeginDrag(PointerEventData eventData)
    {
        //처음에 들어올때 비워주고 다시 넣어줌
        beginDragItemSlot = null;
        endDragItemSlot = null;
        //tempSlotImage.sprite = null;

        //마우스 위에 UI가 올려져있지않다면 작동x
        if (EventSystem.current.IsPointerOverGameObject() == false)
            return;


        if (eventData.pointerCurrentRaycast.gameObject.TryGetComponent<ItemSlot>(out beginDragItemSlot))
        {
            //처음 드래그 될때 해당 slot이 비어있는 거라면 작동x
            if ((beginDragItemSlot == endDragItemSlot) ||
                beginDragItemSlot.itemInfo == ItemManager.Instance.itemList[(int)Define.ScriptableItem.None])
                return;

            tempItemSlot.itemInfo = beginDragItemSlot.itemInfo;

            tempItemSlot.SlotRefresh(tempItemSlot.itemInfo, tempItemSlot.itemCount);
        }
    }

    public void OnDrag(PointerEventData eventData)
    {
        if (beginDragItemSlot.itemInfo == ItemManager.Instance.itemList[(int)Define.ScriptableItem.None])
        {
            tempSlotImage.transform.GetChild(0).localPosition = originTempSlotPos;
            return;
        }

        tempSlotImage.transform.GetChild(0).position = eventData.position;
    }

    public void OnEndDrag(PointerEventData eventData)
    {
        //이 부분 줄이기 최대한 깔끔하게 만들어 보기

        //처음 드래그가 끝날때 tempslot을 다시 제자리로 돌려줌
        tempSlotImage.transform.GetChild(0).localPosition = originTempSlotPos;


        //RectTransformUtility.RectangleContainsScreenPoint
        if (!RectTransformUtility.RectangleContainsScreenPoint(invenRect, eventData.position))
        {
            //EndDrag할때 inven rect범위를 넘으면 삭제 할건지 팝업 창띄워주는부분
            UIManager.Instance.invenPopUp.gameObject.SetActive(true);
            return;
        }

        // 놨을때 gameobj에 itemslot component가 없을시 작동 x 
        if (eventData.pointerCurrentRaycast.gameObject.TryGetComponent<ItemSlot>(out endDragItemSlot))
        {
            if ((beginDragItemSlot == endDragItemSlot) || (endDragItemSlot == null))
                return;

            int EndDragMaxCount = MaxCountReturn(beginDragItemSlot.itemInfo);

            // BeginDarg slot이랑 EndDrag slot이랑 같이 않으면 서로 바꿔줌
            if (endDragItemSlot.itemInfo.itemCode != beginDragItemSlot.itemInfo.itemCode)
            {
                tempItemSlot.itemInfo = endDragItemSlot.itemInfo;
                tempItemSlot.itemCount = endDragItemSlot.itemCount;

                endDragItemSlot.itemInfo = beginDragItemSlot.itemInfo;
                endDragItemSlot.itemCount = beginDragItemSlot.itemCount;

                beginDragItemSlot.itemInfo = tempItemSlot.itemInfo;
                beginDragItemSlot.itemCount = tempItemSlot.itemCount;
            }
            else if (endDragItemSlot.itemInfo.itemCode == beginDragItemSlot.itemInfo.itemCode)
            {
                // 드래그 시작 이랑 끝이랑 아이템이 같을때  합쳐줘야되는데 최대치를 넘으면
                // 최대 소지갯수랑 합친거를 뺀 나머지를 넣어주고 다른  한쪽에는 최대치를 넣어줌
                if ((beginDragItemSlot.itemCount + endDragItemSlot.itemCount) > EndDragMaxCount)
                {
                    int overCount = (beginDragItemSlot.itemCount + endDragItemSlot.itemCount) - EndDragMaxCount;

                    beginDragItemSlot.itemCount = overCount;
                    endDragItemSlot.itemCount = EndDragMaxCount;
                    InvenRefresh();
                }
                else
                {
                    // 합쳤을때 최대 갯수가 아니라면 합쳐주고 처음 드래그 슬롯은 비워줌
                    endDragItemSlot.itemCount += beginDragItemSlot.itemCount;
                    beginDragItemSlot.itemCount = 0;
                    beginDragItemSlot.itemInfo = ItemManager.Instance.itemList[(int)Define.ScriptableItem.None];
                }
            }

        }

        InvenRefresh();
    }

    public void AddItem(ObjInfo obj)
    {
        int itemMaxCount = MaxCountReturn(obj.ItemDrop);

        // 아이템 이 같은게 있다면 갯수만 해당 슬롯에 접근해서
        // 아이템 갯수만 늘려준다.
        for (int i = 0; i < itemSlots.Count; i++)
        {
            //처음에 슬롯들을 검사해서 슬롯에 있는 아이템코드가 같고
            //그 슬롯이 999개보다 작을때 갯수 늘려줌
            if (itemSlots[i].itemInfo.itemCode == obj.ItemDrop.itemCode && (itemSlots[i].itemCount < itemMaxCount)) // 아이템코드가 같을때
            {
                itemSlots[i].itemCount += UnityEngine.Random.Range(899, Define.MaxCount.ObjectMaxDrop);

                //만약에 슬롯에 아이템을 넣어줫는데 최대 갯수를 넘었을때
                //최대갯수 빼고 나머지를 빈슬롯에 넣어 준다
                if (itemSlots[i].itemCount > itemMaxCount)
                {
                    for (int k = 0; k < itemSlots.Count; k++)
                    {
                        if (itemSlots[k].itemInfo == ItemManager.Instance.itemList[(int)Define.ScriptableItem.None])
                        {
                            int overCount = itemSlots[i].itemCount - 999;
                            itemSlots[i].itemCount -= overCount;

                            itemSlots[k].itemInfo = obj.ItemDrop;

                            itemSlots[k].itemCount += overCount;

                            itemSlots[k].SlotRefresh(obj.ItemDrop, itemSlots[k].itemCount);
                            itemSlots[i].SlotRefresh(obj.ItemDrop, itemSlots[i].itemCount);
                            return;
                        }
                    }
                }
                itemSlots[i].SlotRefresh(obj.ItemDrop, itemSlots[i].itemCount);
                return;
            }

        }

        // 아이템이 같은게 없다면 슬롯이 비어있는지 체크후
        // 빈 슬롯에 아이템을 넣어준다
        for (int j = 0; j < itemSlots.Count; j++)
        {
            if (itemSlots[j].itemInfo == ItemManager.Instance.itemList[(int)Define.ScriptableItem.None])
            {
                itemSlots[j].itemInfo = obj.ItemDrop;
                itemSlots[j].itemCount += UnityEngine.Random.Range(899, Define.MaxCount.ObjectMaxDrop);
                itemSlots[j].SlotRefresh(obj.ItemDrop, itemSlots[j].itemCount);
                itemSlots[j].itemInfo = obj.ItemDrop;
                return;
            }
        }

    }

    /// <summary>
    /// 인벤토리 슬롯 전부다 이미지 텍스트를 다시 조정해주는 함수
    /// </summary>
    public void InvenRefresh()
    {
        foreach (ItemSlot slot in itemSlots)
        {
            slot.SlotRefresh();
        }
    }

    /// <summary>
    /// 매개변수로 받은 item의 인벤토리의 최대 갯수를
    /// 반환해주는 함수
    /// </summary>
    /// <param name="item">반환할 아이템</param>
    /// <returns>item의 최대 소지 갯수</returns>
    public int MaxCountReturn(ItemScriptableObj item)
    {
        int itemMaxCount = 0;
        switch (item.itemKind)
        {
            case Define.ItemType.None:
                itemMaxCount = 0;
                break;

            case Define.ItemType.Equipment:
                itemMaxCount = Define.MaxCount.equipment;
                break;

            case Define.ItemType.Ingredient:
                itemMaxCount = Define.MaxCount.ingredient;
                break;

            case Define.ItemType.Potion:
                itemMaxCount = Define.MaxCount.potion;
                break;
        }
        return itemMaxCount;
    }

    /// <summary>
    /// 아이템 버리는 함수
    /// </summary>
    /// <param name="slot">버릴 아이템을 가지고있는 슬롯</param>
    /// <param name="count">버릴 갯수</param>
    public void ItemDestroy(ItemSlot slot, int count)
    {
        //버릴 갯수가 더크면 작동x
        if (count > slot.itemCount)
            return;

        //매개변수 count가 slot itemCount랑 같으면
        //아이템 정보 비워주고 카운트 0으로
        if (count == slot.itemCount)
        {
            slot.itemInfo = ItemManager.Instance.itemList[(int)(Define.ScriptableItem.None)];
            slot.itemCount = 0;
        }
        else
        {
            //버릴갯수가 보유갯수보다 작다면 갯수만 차감
            slot.itemCount -= count;
        }
        InvenRefresh();
    }

    private void OnEnable()
    {
        InvenRefresh();
    }

}
